(ns aleatory.gen.boltzmann
  "This namespace implements a fast generator for
  uniform random trees defined by a tree grammar."

  (:require [aleatory.utils :as u]
            [aleatory.prng.source :as prng]
            #?(:clj [aleatory.gen :as g]
               :cljs [aleatory.gen :as g :refer [Generator]])
            [aleatory.gen.atomic :as atomic])

  #?(:clj (:import [aleatory.gen Generator])))


(defn bintree-grammar
  "A grammar for binary trees, with node labels
  generated by the generator `label-gen`.
  The optional `build-node` function takes 3 arguments,
   the label, the left subtree and the right subtree,
   and build an internal node. It defaults to [[vector]]."
  ([label-gen] (bintree-grammar label-gen vector))
  ([label-gen build-node]
   {:bintree [:either :tip :node]
    :tip [:const 0 nil]
    :node [:build 1 build-node label-gen :bintree :bintree]}))

(defn gentree-grammar
  "A grammar for general trees, with node labels
  generated by the generator `label-gen`.
  The optional `build-node` function takes 2 arguments,
   the label and the forest attached to the node (represented as a list).
  It defaults to [[cons]]."
  ([label-gen] (gentree-grammar label-gen cons))
  ([label-gen build-node]
   {:gentree [:build 1 build-node label-gen :forest]
    :forest [:either :gnil :gcons]
    :gnil [:const 0 ()]
    :gcons [:build 0 cons :gentree :forest]}))

(def ott-grammar
  "This is an example grammar for \"one-two-three\" trees."
  {:ottree [:either :one :two :three]
   :one [:const 1 :one]
   :two [:build 2 (fn [t1 t2] [:two t1 t2]) :ottree :ottree]
   :three [:build 3 (fn [t1 t2 t3] [:three t1 t2 t3]) :ottree :ottree :ottree]})

(declare eval-elem)

(defn eval-const [size z]
  (if (zero? size)
    1.0
    (Math/pow z size)))

(eval-const 0 2.0)
(eval-const 4 2.0)

(defn eval-either [branches z prev]
  (apply + (map #(eval-elem % z prev) branches)))

(defn eval-build [size elems z prev]
  (* (eval-const size z)
     (apply * (map #(eval-elem % z prev) elems))))

(defn eval-elem [elem z prev]
  (if (and (vector? elem) (seq elem))
    (case (first elem)
      (:either :+ :choice :or) (eval-either (rest elem) z prev)
      (:const :value) (eval-const (second elem) z)
      (:build :node) (eval-build (second elem) (rest (rest elem)) z prev)
      ;; else don't know ...
      1.0)
    ;; recursive reference ? 1.0 by default
    (get prev elem 1.0)))

(eval-elem [:const 0 nil] 0.5 {})
(eval-elem [:const 5 nil] 2.0 {})
(eval-elem [:either :one :two] 0.5 {:one 1.0, :two 2.0})
(eval-elem [:build 3 identity 42 :two :three] 2.0 {:two 2.0 :three 3.0})

(defn eval-grammar [grammar z prev]
  (u/mapkv (fn [ref elem] [ref (eval-elem elem z prev)]) grammar))

;; newton iteration
(declare iter)
;; divergence (we went too far)
(declare diverge?)

;; Mr Oracle, please find the singularity
(defn oracle [class zmin zmax eps-iter eps-div]
  ;; (println "[search] zmin=" zmin "zmax=" zmax)
  (if (< (- zmax zmin) eps-iter)
    [zmin (iter class zmin eps-div)]
    (let [z (/ (+ zmin zmax)
               2.0)
          v (iter class z eps-div)]
      ;; (println "  => z=" z "v=" v)
      (if (diverge? v eps-div)
        (recur class zmin z eps-iter eps-div)
        (recur class z zmax eps-iter eps-div)))))

;; distance between vectors v1 and v2
(defn norm [v1 v2]
  (reduce-kv (fn [norm elem y1]
               (let [y2 (get v2 elem)
                     y (Math/abs (- y1 y2))]
                 (if (> y norm) y norm))) 0.0 v1))

(norm {:a 0.1 :b 0.3} {:a 0.2 :b -0.2})

;; iteration until distance is less than `eps` (thank you Mr. Newton)
(defn iter [gram z eps]
  (loop [v1 (u/mapkv (fn [k _] [k 0.0]) gram)]
    (let [v2 (eval-grammar gram z v1)]
      ;; (println "[iter] v2=" v2 "norm=" (norm v1 v2))
      (if (<= (norm v1 v2) eps)
        v2
        (recur v2)))))

;; vector has diverged wrt. eps?
(defn diverge? [v eps]
  (u/some-kv (fn [_ w] (or (< w 0.0) (> w (/ 1.0 eps)))) v))


(oracle ott-grammar 0.0 1.0 0.00001 0.00000001)

(oracle (gentree-grammar identity) 0.0 1.0 0.001 0.000001)

(oracle (bintree-grammar identity) 0.0 1.0 0.001 0.000001)


